#! /usr/bin/env bash

_get_service_port_and_ecshost_and_dockerid() {
  SERVICE_NAME=${1:-unknown}

  _get_ecs_private_ips >/dev/null 2>&1

  local ecshost_and_port
  local ecshost_and_id

  ecshost_and_port=$(for h in ${ECS_HOST_IPS_ARRAY[*]}
  do
    if [[ ${h} != "None" ]]
    then
      PORT=$(ssh ${SSH_OPTIONS} -A -J ec2-user@${BASTION_IP} \
        ec2-user@${h} "docker ps --filter \"name=${SERVICE_NAME}\" --format \"{{.Ports}}\"" | \
        awk -F ':' '{print $2}' | awk -F '-' '{print $1}')
      if [[ -n ${PORT} ]]
      then
        echo "${h} ${PORT}"
        break
      fi
    fi
  done)

  ecshost_and_id=$(for h in ${ECS_HOST_IPS_ARRAY[*]}
  do
    if [[ ${h} != "None" ]]
    then
      ID=$(ssh ${SSH_OPTIONS} -A -J ec2-user@${BASTION_IP} \
        ec2-user@${h} "docker ps --filter \"name=${SERVICE_NAME}\" --format \"{{.ID}}\"")
      if [[ -n ${ID} ]]
      then
        echo "${h} ${ID}"
        break
      fi
    fi
  done)

  if [[ $(IFS=' '; set -f; set -- ${ecshost_and_port}; echo $#) -eq 2 ]] && \
     [[ $(IFS=' '; set -f; set -- ${ecshost_and_id}; echo $#) -eq 2 ]]
  then
    set -- ${ecshost_and_port} ${ecshost_and_id}
    ECSHOST=${1}
    DOCKERPORT=${2}
    DOCKERID=${4}
  else
    fail "No container found where the name contains ${SERVICE_NAME}"
  fi
}

_tunnel_to_ecs_service() {
  SERVICE_NAME=${1:-unknown}
  LOCALPORT=${2:-9999}
  _get_service_port_and_ecshost_and_dockerid ${SERVICE_NAME}

  _copy_public_key_to_bastion
  ssh -f -Nn -J ec2-user@${BASTION_IP} -L ${LOCALPORT}:localhost:${DOCKERPORT} ec2-user@${ECSHOST}

  if [[ $? -eq 0 ]]
  then
    echo "INFO: Tunnel to service ${SERVICE_NAME} is established on localhost:${LOCALPORT}"
    echo "      The tunnel is running in the background, do not forget to kill the"
    echo "      corresponding ssh process."
  else
    fail "An error occured setting up the tunnel to service ${SERVICE}"
  fi
}

_dockerexec() {
  # This will not be possible when using SSM and ec2-instance-connect
  SERVICE_NAME=${1}
  CMD=${2}
  _get_service_port_and_ecshost_and_dockerid ${SERVICE_NAME}

  ssh -tt -J ec2-user@${BASTION_IP} ec2-user@${ECSHOST} "docker exec -ti ${DOCKERID} ${CMD}"
}

_get_bastion_ip() {
  set -- $(aws ec2 describe-instances \
    --filters "Name=tag:Name,Values=*astion*" \
    --query "Reservations[*].Instances[*].[PublicIpAddress,KeyName,PrivateIpAddress,InstanceId,Placement.AvailabilityZone]" \
    --output text | grep -v ^None)
  if [ -n "${1}" -a -n "${2}" -a -n "${3}" -a -n "${4}" ]
  then
    BASTION_IP=${1}
    if [[ -n ${AWS_SSH_FORCE_SSH_KEY} ]]; then
      AWS_SSH_KEYNAME=${AWS_SSH_FORCE_SSH_KEY}
    elif [[ "${2}" != "None" ]]; then
      AWS_SSH_KEYNAME=${2}
    else
      [[ ${AWS_SSH_SSM:-0} != 1 ]] && warning "The bastion has no KeyName, switching to SSM for authentication."
      export AWS_SSH_SSM=1
    fi
    if [[ ${AWS_SSH_KEYNAME} != /* ]] && [[ ${AWS_SSH_SSM:-0} != 1 ]]; then
      AWS_SSH_KEYNAME=${PKH:-~/.ssh}/${AWS_SSH_KEYNAME}
    fi

    BASTION_PRIVATE_IP=${3}
    BASTION_INSTANCE_ID=${4}
    BASTION_AZ=${5}
  else
    warning "Unable to find a bastion EC2 instance"
  fi
}

_get_ecs_private_ips() {
  ECS_HOST_IPS_1=$(aws ec2 describe-instances \
    --filters "Name=tag:ECSClusterName,Values=*" \
    --query "Reservations[*].Instances[*].[PrivateIpAddress]" \
    --output text)
  ECS_HOST_IPS_2=$(aws ec2 describe-instances \
    --filters "Name=tag:Name,Values=*ECS*" \
    --query "Reservations[*].Instances[*].[PrivateIpAddress]" \
    --output text)

  ECS_HOST_IPS="${ECS_HOST_IPS_1} ${ECS_HOST_IPS_2}"

  ECS_HOST_IPS_ARRAY=(${ECS_HOST_IPS//None/})

  if [[ -z ${ECS_HOST_IPS} ]]
  then
    echo "ERROR - Unable to find ECS hosts"
    exit 1
  fi
}

_get_rds_endpoints() {
  RDS_ENDPOINTS=$(aws rds describe-db-instances \
    --query "DBInstances[*].Endpoint.[Address,Port]" \
    --output text | tr '[:space:]' ':')

  if [[ -z ${RDS_ENDPOINTS} ]]; then
    fail "Unable to find RDS instances"
  fi
}

_get_ec2_instances() {
    EC2_INSTANCES=$(aws ec2 describe-instances \
      --query "Reservations[*].Instances[*].[PrivateIpAddress,InstanceId,Placement.AvailabilityZone,Tags[?Key=='Name'].Value,State.Name][]" | \
      jq -r '.[] | .[0] + ":" + .[1]+ ":" + .[2] + ":" + .[3][0] + ":" + .[4]|split(" ")|join("")')

  if [[ -z ${EC2_INSTANCES} ]]; then
    fail "Unable to find EC2 instances"
  fi
}

_get_ssm_instances() {
  SSM_INSTANCES=$(aws ssm describe-instance-information \
    --query "InstanceInformationList[*].[InstanceId, PlatformType, PlatformName, ComputerName]" | \
    jq -r '.[] | .[0] + ":" + .[1]+ ":" + .[2] + ":" + .[3]|split(" ")|join("")')

  if [[ -z ${SSM_INSTANCES} ]]; then
    fail "Unable to find EC2 instances"
  fi
}

_copy_public_key_to_bastion() {
  if [[ ${AWS_SSH_SSM:-0} == 1 ]]; then
    if aws ec2-instance-connect send-ssh-public-key \
      --instance-id ${BASTION_INSTANCE_ID} \
      --availability-zone ${BASTION_AZ} \
      --instance-os-user ec2-user \
      --ssh-public-key file://${AWS_SSH_PUBKEY:-${HOME}/.ssh/id_rsa.pub} >/dev/null 2>&1; then
        success "Successfully copied ${AWS_SSH_PUBKEY:-${HOME}/.ssh/id_rsa.pub} to bastion host."
    else
        fail "An error occurred while copying ${AWS_SSH_PUBKEY:-${HOME}/.ssh/id_rsa.pub} to bastion host."
    fi
  fi
}

_load_private_key() {
  local aws_ssh_key_dirname
  local aws_ssh_key_basename

  ### Load the private Key
  if [[ ${AWS_SSH_SSM:-0} == 1 ]]; then
    aws_ssh_key_dirname=$(dirname ${AWS_SSH_SSM_PRIVKEY:-~/.ssh/dummy})
    aws_ssh_key_basename=$(basename ${AWS_SSH_SSM_PRIVKEY:-id_rsa})
  else
    aws_ssh_key_dirname=$(dirname "${AWS_SSH_KEYNAME}")
    aws_ssh_key_basename=$(basename "${AWS_SSH_KEYNAME}")
  fi

  if ssh-add -l | grep -q "${aws_ssh_key_dirname}/${aws_ssh_key_basename}"
  then
    info "Private key ${aws_ssh_key_dirname}/${aws_ssh_key_basename} already loaded"
  elif [[ -e ${aws_ssh_key_dirname}/${aws_ssh_key_basename} ]]
  then
    ssh-add "${aws_ssh_key_dirname}/${aws_ssh_key_basename}"
  elif [[ -e ${aws_ssh_key_dirname}/${aws_ssh_key_basename}.pem ]]
  then
    ssh-add "${aws_ssh_key_dirname}/${aws_ssh_key_basename}.pem"
  elif [[ -e ${aws_ssh_key_dirname}/id_rsa_${aws_ssh_key_basename} ]]
  then
    ssh-add "${aws_ssh_key_dirname}/id_rsa_${aws_ssh_key_basename}"
  elif [[ -e ${aws_ssh_key_dirname}/id_rsa_${aws_ssh_key_basename}.pem ]]
  then
    ssh-add "${aws_ssh_key_dirname}/id_rsa_${aws_ssh_key_basename}.pem"
  else
    warning "Private key not found, trying to connect using SSM"
    AWS_SSH_SSM=1
  fi
}

_selection_menu() {
  SAVED_PS3="${PS3}"
  SAVED_COLUMNS="${COLUMNS}"

  PS3="Enter a number: "
  COLUMNS="20"
  select choice in ${@}; do
    if [[ ${REPLY} -gt 0 && ${REPLY} -le ${#} ]]; then
      SELECTION_CHOICE=${choice}
      break
    fi
  done
  PS3="${SAVED_PS3}"
  COLUMNS="${SAVED_COLUMNS}"
}

typeset -a ECS_HOST_IPS_ARRAY

gray='\033[37m'
blue='\033[36m'
red='\033[31m'
green='\033[32m'
orange='\033[33m'
reset='\033[0m'

info()    { echo -e "${blue}INFO: $*${reset}"; }
plain()   { echo -e "${green}$*${reset}"; }
warning() { echo -e "${orange}WARN: $*${reset}"; }
error()   { echo -e "${red}ERROR: $*${reset}"; }
success() { echo -e "${green}✔ $*${reset}"; }
fail()    { echo -e "${red}✖ $*${reset}"; exit 1; }
debug()   { [[ "${DEBUG}" == "true" ]] && echo -e "${gray}DEBUG: $*${reset}" || true; }

BASTION_IP=""
BASTION_PRIVATE_IP=""
AWS_SSH_KEYNAME=""
ECS_HOST_IPS=""
RDS_ENDPOINTS=""
SSH_OPTIONS="-oStrictHostKeyChecking=no"

[[ ${AWS_SSH_SSM} -eq 1 ]] || warning "Envvar AWS_SSH_SSM not set to 1, not using SSM to connect."
[[ -n ${PRIVKEYHOME} ]] && PKH=${PRIVKEYHOME}
[[ -n ${AWS_SSH_PRIVKEYHOME} ]] && PKH=${AWS_SSH_PRIVKEYHOME}

case ${1} in
  bastion|ecs|ec2|ssm|rdstunnel|dockerps|ecsservicetunnel|dockerexec )
    _get_bastion_ip
    _load_private_key
    ;;
  * )
    info "Usage:"
    info "  ${0} bastion [command]"
    info "  ${0} ecs [command]"
    info "  ${0} ec2"
    info "  ${0} ssm"
    info "  ${0} dockerps"
    info "  ${0} rdstunnel"
    info "  ${0} ecsservicetunnel <service>"
    info "  ${0} dockerexec <service>"
    info ""
    info "Set PRIVKEYHOME or AWS_SSH_PRIVKEYHOME envvar to tell me"
    info "where your private keys are."
    info "Default is ~/.ssh"
    info "Set AWS_SSH_FORCE_SSH_KEY to override use of bastions key"
    info "in favor of your own key (requires your pubkey to be present"
    info "on the EC2 instances)"
    ;;
esac

case ${1} in
  bastion )
    info "Log in to bastion account"
    shift
    _copy_public_key_to_bastion
    ssh ${SSH_OPTIONS} -t -A ec2-user@${BASTION_IP} ${@}
    ;;
  ecs )
    _get_ecs_private_ips
    info "Show commands to connect to ECS ec2 instances"
    shift
    for h in ${ECS_HOST_IPS_ARRAY[*]}
    do
      if [[ ${h} != "None" ]]
      then
        echo "ssh ${SSH_OPTIONS} -t -A ec2-user@${BASTION_IP} 'ssh ${SSH_OPTIONS} -A ${h} ${@}'"
        if [[ ${#ECS_HOST_IPS_ARRAY[@]} -eq 1 ]]
        then
          ssh ${SSH_OPTIONS} -t -A ec2-user@${BASTION_IP} "ssh ${SSH_OPTIONS} -A ${h} ${@}"
        fi
      fi
    done
    ;;
  ec2 )
    plain ""
    plain "Select the EC2 instance to connect to using SSM:"
    _get_ec2_instances

    _selection_menu ${EC2_INSTANCES}

    SAVED_IFS="${IFS}"
    IFS=':' read -a array <<< "${SELECTION_CHOICE}"
    IFS="${SAVED_IFS}"

    info "Starting SSM session to EC2 instance with name tag ${array[3]}."
    aws ssm start-session --target "${array[1]}"
    ;;
  ssm )
    plain ""
    plain "Select the SSM managed instance to connect to using:"
    _get_ssm_instances

    _selection_menu ${SSM_INSTANCES}

    SAVED_IFS="${IFS}"
    IFS=':' read -a array <<< "${SELECTION_CHOICE}"
    IFS="${SAVED_IFS}"

    info "Starting SSM session to EC2 instance with name tag ${array[3]}."
    aws ssm start-session --target "${array[0]}"
    ;;
  rdstunnel )
    plain ""
    plain "Select the DB to setup a tunnel to from this list:"
    _get_rds_endpoints
    _selection_menu ${RDS_ENDPOINTS}

    SAVED_IFS="${IFS}"
    IFS=':' read -a array <<< "${SELECTION_CHOICE}"
    IFS="${SAVED_IFS}"

    _copy_public_key_to_bastion
    info "Starting local tunnel to ${array[0]} on port ${array[1]}."
    info "SSH Tunnel will start in foreground, use Ctrl-C to close the tunnel."
    ssh ${SSH_OPTIONS} -Nnt -A -L ${array[1]}:${array[0]}:${array[1]} ec2-user@${BASTION_IP}
    ;;
  dockerps )
    info "Show docker container info on all ECS hosts"
    _get_ecs_private_ips
    for h in ${ECS_HOST_IPS_ARRAY[*]}
    do
      if [[ ${h} != "None" ]]
      then
        info "Show docker containers on ${h}"
        ssh ${SSH_OPTIONS} -t -A ec2-user@${BASTION_IP} "ssh ${SSH_OPTIONS} -A ${h} docker ps --format \\\"table {{.ID}}\\\t{{.Image}}\\\""
      fi
    done
    ;;
  ecsservicetunnel)
    _tunnel_to_ecs_service "${2:unknown}" "${3}"
    ;;
  dockerexec)
    _dockerexec "${2:unknown}" "${3:-/bin/bash}"
    ;;

esac
